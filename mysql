前言

磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：

图片

various-system-software-hardware-latencies



考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。[copy]

Mysql server

链接器、分析器、优化器、执行器

储存引擎

mysq的存储引擎主要有innodb(B+)、myisam（B+)、memory(哈希）

memory 基于内存的最快

innodb
myisam
支持事务
不支持事务
支持表锁、行所
只支持表锁
数据文件和索引文件不分开，元信息文件
数据文件和索引文件分开，元信息文件
直接可以count(*)
需要统计
叶子节点的键值域，值域保存数据
叶子节点的键值域，值域保存指针
支持外键
不支持外键
大量update、insert、delete	大量select
表默认是innodb，innodb在没有显示定义主键的时候，引擎会自动定义一个rowid作为主键。

myisam内部有个一auto_incrment的内部列，当插入或者更新该列的时候，这个内部列也会更新，这个列的更新比innoddb的autoz_incrment快

如何选择

myisam性能更高，占用的内存更少，并且索引和数据分开的，索引是经过压缩的，节省内存并且查找也快，适用于查询大的情况。

innodb支持事务，对多并发的情况，用innodb。

索引

mysql的索引:主要B数、B+树和哈希(memory)

B数非叶子节点不仅有n-1个key(不仅有索引值，还有data域的数据值）节点，还n个point 节点；叶子节点的指针都为空。

B+树非叶子节点只有索引字段节点和指针节点，都是N个；其中叶子节点没有指针域，只有键值域（索引键和记录域）【上层的节点会在下层都出现的】

索引分类：主键索引（不允许重复、不允许为空）、唯一索引（不允许重复，可以为空）、普通索引（允许空）、全文索引、组合索引（多个列中的值不允许有空值，最左匹配原则）

索引原则：

最左匹配

=和in可以乱序使用

尽量选择区分度高的列作为索引

对索引不要进行计算，计算结果和索引完全是不一样的结果，检索成本高

尽量扩展索引，不要新建索引

索引的优缺点：

优点：加快检索和查询的所读，减少io的次数

缺点：索引表也是表，会占用存储空间，大概是数据表的1.5倍。索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够;创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行

聚集索引和非聚集索引:

聚集索引：代表innodb，它是主键索引的键值对域（节点）的主键和值（数据）放在叶子节点；辅助索引键值对域（节点）的辅助键和值（主键索引的键）放在叶子节点；最好按照自增的键来插入，否则会引起索引的分裂，也就是磁盘页的分裂，增加维护开销；

非聚集索引：代表myisam,他是主键索引的索引键和值（记录）分开的一种；主键索引和辅助索引是两种索引，除了数据（记录）没有其他关系；只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。

图片

注意点：

回表-innodb，先查辅助索引，在通过主键索引找到数据【解决--简历包含的联合索引】

索引下推--新版本的功能，联合索引的所有字段都会比较；之前是只比价第一个

最左匹配原则【列字段最左，某个字段最左边的字符】

InnoDB的二级索引带来的好处就是减少了由于数据移动或者数据页分列导致行数据的地址变了而带来的维护二级索引的性能开销，因为InnoDB的二级索引不需要更新行指针



事务

特性

Atomicity（原子性）：不能再分割，最小单元，undo log（执行跟用户相反的操作，类似回溯）

Consistency(一致性）：一个状态到另一个状态

isolation（隔离性）：一个事务做的可能改变，对其他事务来说不可以见，注意这里的“通常来说”，后面的事务隔离级级别会说到（锁），通常指事务的隔离性。【mvcc多版本并发控制】

Duration（持久性）：做的操作不丢失。redo log

特性的解决方案：

隔离性是通过锁或者mvcc解决的

其他是通过事务日志实现

隔离级别

读未提交：一个事务修改了某个记录，但是在未提交前被另一个事务读取到了；

读提交：读取别的事务已经提交的数据，不能重复读

可重复读：

串行化

并发带来的问题：

更新丢失（数据丢失）：两个人同时修改，一个数据覆盖另一个数据

脏读：一个事务在修改数据期间，另一个事务读取了这部分修改不完全的数据，这部分数据就是脏读。

不可重复读：一个事务在读取周期内，两次读取数据后，发现读取到的数据不一致；因为第二个事务在这期间对数据做了修改；侧重修改

幻读：一个事务读取了数据（大量的），然后另一个事务插入或者删除了数据，第一个事务重新读的时候发现结果不一致；侧重新增或者删除

图片

mvcc解决读提交和重复读,可能解决幻读的问题。



主从复制

binlog 的三种模式：statement、row和mix

MySQL的主从复制和读写分离两者有着紧密的联系，首先要部署主从复制，只有主从复制完成了才能在此基础上进行数据的读写分离。

图片

复制过程：前提是主节点开启了binlog同步，master有更新的时候，也会把更新写到binlog中；首先salve创建io线程请求连接master，这时候主节点会创建一个dump log 的线程，这个线程将最新的binlog数据传给salve，salve会将数据写到relay log中，再有sql线程将中继日志写入salve库

图片

同步过程中会有同步延迟

读写分离

实现MySQL读写分离的前提是我们已经将MySQL主从复制配置完毕，读写分离实现方式：（1）配置多数据源。（2）使用mysql的proxy中间件代理工具。

主库负责读写

读库只负责读

xxx

分库分表

分表

首先为什么要分表？（1） 如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I/O操作 （2）如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响查询的性能。（3）表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。（4） 分表技术有(水平分割和垂直分割)

垂直分割
垂直分割是指数据表列的拆分，把一张列比较多的表拆分为多张表。垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。

垂直分割比较常见：例如博客系统中的文章表，比如文章tbl_articles (id, titile, summary, content, user_id, create_time)，因为文章中的内容content会比较长，放在tbl_articles中会严重影响表的查询速度，所以将内容放到tbl_articles_detail(article_id, content)，像文章列表只需要查询tbl_articles中的字段即可。

垂直拆分的优点：可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。

垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。

水平分割
水平拆分是指数据表行数据的拆分，表的行数超过500万行或者单表容量超过10GB时，查询就会变慢，这时可以把一张的表的数据拆成多张表来存放。水平分表尽可能使每张表的数据量相当，比较均匀。

水平拆分会给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点。

因为只要索引关键字不大，则在索引用于查询时，表中增加2-3倍数据量，查询时也就增加读一个索引层的磁盘次数，所以水平拆分要考虑数据量的增长速度，根据实际情况决定是否需要对表进行水平拆分。

水平分割最重要的是找到分割的标准，不同的表应根据业务找出不同的标准

用户表可以根据用户的手机号段进行分割如user183、user150、user153、user189等，每个号段就是一张表。
用户表也可以根据用户的id进行分割，加入分3张表user0,user1,user2，如果用户的id%3=0就查询user0表，如果用户的id%3=1就查询user1表。
对于订单表可以按照订单的时间进行分表。
分库

现在市面上主要的分库分表技术有mycat和sharding-jdbc

锁

xxx

xxxx

mvcc

xxxx

xxxx

xx

日志系统

xxx

xxx

xxx
